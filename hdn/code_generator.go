package main

import (
	"fmt"
	"log"
	"strings"
	"time"
)

// CodeGenerator handles generating executable code using Ollama
type CodeGenerator struct {
	llmClient   *LLMClient
	codeStorage *CodeStorage
}

// CodeGenerationRequest represents a request to generate code
type CodeGenerationRequest struct {
	TaskName    string            `json:"task_name"`
	Description string            `json:"description"`
	Language    string            `json:"language"`
	Context     map[string]string `json:"context"`
	Tags        []string          `json:"tags"`
	Executable  bool              `json:"executable"`
	Tools       []Tool            `json:"tools,omitempty"`        // Available tools to use
	ToolAPIURL  string            `json:"tool_api_url,omitempty"` // Base URL for tool API
}

// CodeGenerationResponse represents the response from code generation
type CodeGenerationResponse struct {
	Code        *GeneratedCode `json:"code"`
	Success     bool           `json:"success"`
	Error       string         `json:"error,omitempty"`
	Suggestions []string       `json:"suggestions,omitempty"`
}

func NewCodeGenerator(llmClient *LLMClient, codeStorage *CodeStorage) *CodeGenerator {
	return &CodeGenerator{
		llmClient:   llmClient,
		codeStorage: codeStorage,
	}
}

// GenerateCode generates executable code for a given task
func (cg *CodeGenerator) GenerateCode(req *CodeGenerationRequest) (*CodeGenerationResponse, error) {
	// Build a code generation prompt
	prompt := cg.buildCodeGenerationPrompt(req)

	// Debug: log the exact LLM prompt used for code generation (truncated to avoid log flooding)
	if p := strings.TrimSpace(prompt); p != "" {
		max := 4000
		if len(p) > max {
			log.Printf("ðŸ“ [CODEGEN] LLM prompt (truncated %d/%d chars):\n%s...", max, len(p), p[:max])
		} else {
			log.Printf("ðŸ“ [CODEGEN] LLM prompt (%d chars):\n%s", len(p), p)
		}
	}

	// Call Ollama to generate code
	response, err := cg.llmClient.callLLM(prompt)
	if err != nil {
		return &CodeGenerationResponse{
			Success: false,
			Error:   fmt.Sprintf("Failed to generate code: %v", err),
		}, nil
	}

	// Extract code from response
	code, err := cg.extractCodeFromResponse(response, req.Language)
	if err != nil {
		return &CodeGenerationResponse{
			Success: false,
			Error:   fmt.Sprintf("Failed to extract code: %v", err),
		}, nil
	}

	// Clean up the code to remove test cases and error handling
	code = cg.cleanGeneratedCode(code, req.Language)

	// Create GeneratedCode object
	generatedCode := &GeneratedCode{
		ID:          fmt.Sprintf("code_%d", time.Now().UnixNano()),
		TaskName:    req.TaskName,
		Description: req.Description,
		Language:    req.Language,
		Code:        code,
		Context:     req.Context,
		CreatedAt:   time.Now(),
		Tags:        req.Tags,
		Executable:  req.Executable,
	}

	// Store in Redis
	err = cg.codeStorage.StoreCode(generatedCode)
	if err != nil {
		return &CodeGenerationResponse{
			Success: false,
			Error:   fmt.Sprintf("Failed to store code: %v", err),
		}, nil
	}

	// Generate suggestions for improvement
	suggestions := cg.generateSuggestions(generatedCode)

	return &CodeGenerationResponse{
		Code:        generatedCode,
		Success:     true,
		Suggestions: suggestions,
	}, nil
}

// cleanGeneratedCode removes test cases and error handling from generated code
func (cg *CodeGenerator) cleanGeneratedCode(code, language string) string {
	// Be conservative: only strip surrounding markdown code fences if present.
	trimmed := strings.TrimSpace(code)
	if strings.HasPrefix(trimmed, "```") {
		// Remove the starting fence (optionally with language)
		newlineIdx := strings.Index(trimmed, "\n")
		if newlineIdx != -1 {
			trimmed = trimmed[newlineIdx+1:]
		} else {
			// Single-line fence; return as-is
			return code
		}
	}
	if strings.HasSuffix(trimmed, "```") {
		trimmed = strings.TrimSuffix(trimmed, "```")
	}
	return strings.TrimSpace(trimmed)
}

// buildCodeGenerationPrompt creates a prompt for code generation
func (cg *CodeGenerator) buildCodeGenerationPrompt(req *CodeGenerationRequest) string {
	// Special case for daily_summary - generate a simple placeholder
	if strings.EqualFold(req.TaskName, "daily_summary") {
		return `Generate a simple Python script that prints a placeholder message for daily summary generation.

This is a placeholder task - the actual daily summary will be generated by the system using real data.
Just print a message indicating this is a placeholder.

Code:`
	}

	contextStr := ""
	filePathInfo := ""

	if len(req.Context) > 0 {
		contextStr = "\nContext:\n"
		for k, v := range req.Context {
			contextStr += fmt.Sprintf("- %s: %s\n", k, v)
			// Check if this looks like a data file reference
			if (strings.Contains(strings.ToLower(k), "data") ||
				strings.Contains(strings.ToLower(k), "file") ||
				strings.Contains(strings.ToLower(k), "source") ||
				strings.Contains(strings.ToLower(k), "input")) &&
				strings.Contains(v, ".") && !strings.Contains(v, " ") {
				filePathInfo += fmt.Sprintf("\nIMPORTANT: The file '%s' is available at '/app/data/%s' in the container.\n", v, v)
			}
		}
	}

	tagsStr := ""
	if len(req.Tags) > 0 {
		tagsStr = fmt.Sprintf("\nTags: %s\n", strings.Join(req.Tags, ", "))
	}

	// Build tool information section
	toolsSection := ""
	if len(req.Tools) > 0 && req.ToolAPIURL != "" {
		toolsSection = "\n\nðŸ”§ AVAILABLE TOOLS - USE THESE INSTEAD OF DUMMY DATA:\n"
		toolsSection += "CRITICAL: If the task requires functionality that matches these tools, you MUST use the tools instead of generating dummy implementations.\n"
		toolsSection += fmt.Sprintf("Tool API Base URL: %s\n\n", req.ToolAPIURL)

		for _, tool := range req.Tools {
			toolsSection += fmt.Sprintf("Tool: %s (%s)\n", tool.ID, tool.Name)
			toolsSection += fmt.Sprintf("Description: %s\n", tool.Description)
			if len(tool.InputSchema) > 0 {
				toolsSection += "Parameters:\n"
				for param, paramType := range tool.InputSchema {
					toolsSection += fmt.Sprintf("  - %s (%s)\n", param, paramType)
				}
			}
			toolsSection += fmt.Sprintf("Call: POST %s/api/v1/tools/%s/invoke\n", req.ToolAPIURL, tool.ID)
			toolsSection += "Request Body: JSON object with parameters\n\n"
		}

		// Add examples for common languages
		toolsSection += "EXAMPLES:\n\n"

		// Python example
		toolsSection += "Python - Call HTML Scraper:\n"
		toolsSection += "```python\n"
		toolsSection += "import requests\n"
		toolsSection += "import json\n"
		toolsSection += "url = 'https://example.com'\n"
		toolsSection += fmt.Sprintf("response = requests.post('%s/api/v1/tools/tool_html_scraper/invoke',\n", req.ToolAPIURL)
		toolsSection += "    json={'url': url})\n"
		toolsSection += "data = response.json()\n"
		toolsSection += "# Process data['items'] or data['output']\n"
		toolsSection += "print(json.dumps(data, indent=2))\n"
		toolsSection += "```\n\n"

		// Go example
		toolsSection += "Go - Call Tool API:\n"
		toolsSection += "```go\n"
		toolsSection += "package main\n"
		toolsSection += "import (\n"
		toolsSection += "    \"bytes\"\n"
		toolsSection += "    \"encoding/json\"\n"
		toolsSection += "    \"fmt\"\n"
		toolsSection += "    \"io\"\n"
		toolsSection += "    \"net/http\"\n"
		toolsSection += ")\n"
		toolsSection += "url := \"https://example.com\"\n"
		toolsSection += "jsonData, _ := json.Marshal(map[string]string{\"url\": url})\n"
		toolsSection += fmt.Sprintf("resp, _ := http.Post(\"%s/api/v1/tools/tool_http_get/invoke\",\n", req.ToolAPIURL)
		toolsSection += "    \"application/json\", bytes.NewBuffer(jsonData))\n"
		toolsSection += "defer resp.Body.Close()\n"
		toolsSection += "body, _ := io.ReadAll(resp.Body)\n"
		toolsSection += "var result map[string]interface{}\n"
		toolsSection += "json.Unmarshal(body, &result)\n"
		toolsSection += "```\n\n"
	}

	return fmt.Sprintf(`ðŸš« CRITICAL RESTRICTION - MUST FOLLOW:
- NEVER use Docker commands (docker run, docker build, docker exec, etc.) - Docker is NOT available
- NEVER use subprocess.run with docker commands - this will cause FileNotFoundError
- NEVER use os.system with docker commands - this will fail
- You are already running inside a container, do NOT try to create more containers

Generate clean, executable %s code for this task.

Task: %s
Description: %s%s%s%s

UNIQUE TASK ID: %s_%d

Generate ONLY the core functionality:
1. Define the main function(s) needed
2. Add basic comments
3. Include necessary imports (prefer standard library when possible)
4. The main execution should run the core task and PRINT the result

IMPORTANT: 
- The program must compile cleanly with the language's standard compiler (for Go: `+"`go build`"+`) with no unused variables or imports
- Use ONLY the standard library unless explicitly requested otherwise
- Use ASCII identifiers only (no non-ASCII names)
- If tools are available above, you MUST use them instead of dummy data
- Do NOT create hardcoded dummy data when tools can fetch real data
- For web scraping: use tool_html_scraper or tool_http_get if available
- For file operations: use tool_file_read or tool_file_write if available
- Only perform direct network calls if no tool is available
- The code must include a print statement to output the result
  * For Go: use fmt.Print() or fmt.Println() (NOT the built-in print() function). Ensure you import "fmt" and "io" packages if using io.ReadAll()
  * For Python: use print()
  * For JavaScript: use console.log()
- Use the correct file paths for any data files (see IMPORTANT notes above)
- For mathematical tasks, create appropriate functions and print the results
- For data processing tasks, create functions that process the data and print the results
- Don't create test functions or validation functions - create the actual functionality
- MINIMIZE external dependencies - use standard library modules when possible
- NEVER use input() or any user input functions - use the context parameters directly
- NEVER ask for user input - the code should run automatically with the given context
- NEVER use Docker commands (docker run, docker build, etc.) - Docker is not available in the execution environment

DO NOT include:
- Test cases
- Error handling with print statements
- Example usage with different inputs
- Validation code that runs automatically
- Any code that prints error messages
- Functions that test or validate - create the actual functionality
- Heavy data science libraries unless absolutely necessary
- input() or any user input functions
- Any code that waits for user interaction
- Docker commands (docker run, docker build, etc.) - Docker is not available
- Any comments mentioning Docker, containers, or containerization
- Any references to Docker in comments or strings

The code should run once and print only the expected result. Ensure it compiles without errors before returning.

%sCode:`, req.Language, req.TaskName, req.Description, contextStr, filePathInfo, tagsStr, req.TaskName, time.Now().UnixNano(), toolsSection)
}

// extractCodeFromResponse extracts code from the LLM response
func (cg *CodeGenerator) extractCodeFromResponse(response, language string) (string, error) {
	// Look for code blocks in the response
	codeBlockStart := fmt.Sprintf("```%s", language)
	codeBlockEnd := "```"

	startIdx := strings.Index(response, codeBlockStart)
	if startIdx == -1 {
		// Try generic code block
		startIdx = strings.Index(response, "```")
		if startIdx == -1 {
			return "", fmt.Errorf("no code block found in response")
		}
		// Skip the ```
		startIdx += 3
	} else {
		// Skip the ```language
		startIdx += len(codeBlockStart)
	}

	// Find the end of the code block
	endIdx := strings.Index(response[startIdx:], codeBlockEnd)
	if endIdx == -1 {
		return "", fmt.Errorf("no closing code block found")
	}

	// Extract the code
	code := strings.TrimSpace(response[startIdx : startIdx+endIdx])

	if code == "" {
		return "", fmt.Errorf("extracted code is empty")
	}

	return code, nil
}

// generateSuggestions creates suggestions for improving the generated code
func (cg *CodeGenerator) generateSuggestions(code *GeneratedCode) []string {
	var suggestions []string

	// Language-specific suggestions
	switch code.Language {
	case "go":
		suggestions = append(suggestions, "Consider adding unit tests")
		suggestions = append(suggestions, "Add proper error handling with custom error types")
		suggestions = append(suggestions, "Consider using interfaces for better testability")
	case "python":
		suggestions = append(suggestions, "Add type hints for better code clarity")
		suggestions = append(suggestions, "Consider using dataclasses or pydantic for data structures")
		suggestions = append(suggestions, "Add docstrings following PEP 257")
	case "javascript", "typescript":
		suggestions = append(suggestions, "Add JSDoc comments for better documentation")
		suggestions = append(suggestions, "Consider using TypeScript for better type safety")
		suggestions = append(suggestions, "Add proper error handling with try-catch blocks")
	}

	// General suggestions
	suggestions = append(suggestions, "Add logging for debugging and monitoring")
	suggestions = append(suggestions, "Consider adding configuration management")
	suggestions = append(suggestions, "Add input validation and sanitization")

	return suggestions
}

// SearchCode searches for previously generated code
func (cg *CodeGenerator) SearchCode(query string, language string, tags []string) ([]CodeSearchResult, error) {
	return cg.codeStorage.SearchCode(query, language, tags)
}

// GetCode retrieves code by ID
func (cg *CodeGenerator) GetCode(id string) (*GeneratedCode, error) {
	return cg.codeStorage.GetCode(id)
}

// ListAllCode lists all generated code
func (cg *CodeGenerator) ListAllCode() ([]*GeneratedCode, error) {
	return cg.codeStorage.ListAllCode()
}

// DeleteCode removes code by ID
func (cg *CodeGenerator) DeleteCode(id string) error {
	return cg.codeStorage.DeleteCode(id)
}

// GenerateCodeFromTask generates code based on an existing HTN task
func (cg *CodeGenerator) GenerateCodeFromTask(taskName, description string, context map[string]string) (*CodeGenerationResponse, error) {
	// Determine language from context or default to Go
	language := "go"
	if lang, exists := context["language"]; exists {
		language = lang
	}

	// Extract tags from context
	var tags []string
	if taskTags, exists := context["tags"]; exists {
		tags = strings.Split(taskTags, ",")
		for i, tag := range tags {
			tags[i] = strings.TrimSpace(tag)
		}
	}

	req := &CodeGenerationRequest{
		TaskName:    taskName,
		Description: description,
		Language:    language,
		Context:     context,
		Tags:        tags,
		Executable:  true,
	}

	return cg.GenerateCode(req)
}
