package mapper

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"principles/internal/analyzer"
	"time"
)

// DynamicActionMapper handles dynamic task mapping for LLM-generated tasks
type DynamicActionMapper struct {
	principlesAPIURL string
	httpClient       *http.Client
	analyzer         *analyzer.TaskAnalyzer
}

// LLMTask represents a task generated by an LLM
type LLMTask struct {
	TaskName    string                 `json:"task_name"`
	Description string                 `json:"description"`
	TaskType    string                 `json:"task_type,omitempty"`
	Context     map[string]interface{} `json:"context,omitempty"`
	SubTasks    []LLMTask              `json:"sub_tasks,omitempty"`
	GeneratedBy string                 `json:"generated_by,omitempty"` // "llm", "human", "system"
}

// TaskCheckResult represents the result of checking a task against principles
type TaskCheckResult struct {
	TaskName       string                 `json:"task_name"`
	Allowed        bool                   `json:"allowed"`
	Reasons        []string               `json:"reasons,omitempty"`
	Analysis       *analyzer.TaskAnalysis `json:"analysis,omitempty"`
	SubTaskResults []TaskCheckResult      `json:"sub_task_results,omitempty"`
	Error          string                 `json:"error,omitempty"`
}

// NewDynamicActionMapper creates a new dynamic action mapper
func NewDynamicActionMapper(principlesAPIURL string) *DynamicActionMapper {
	return &DynamicActionMapper{
		principlesAPIURL: principlesAPIURL,
		httpClient: &http.Client{
			Timeout: 30 * time.Second, // Longer timeout for complex analysis
		},
		analyzer: analyzer.NewTaskAnalyzer(),
	}
}

// CheckTask checks a single task against ethical principles
func (dam *DynamicActionMapper) CheckTask(task LLMTask) *TaskCheckResult {
	// Analyze the task to extract ethical context
	analysis := dam.analyzer.AnalyzeTask(task.TaskName, task.Description, task.Context)

	// Create principles request
	principlesReq := dam.createPrinciplesRequest(task, analysis)

	// Check with principles API
	allowed, reasons, err := dam.checkWithPrinciplesAPI(principlesReq)

	result := &TaskCheckResult{
		TaskName: task.TaskName,
		Allowed:  allowed,
		Reasons:  reasons,
		Analysis: analysis,
	}

	if err != nil {
		result.Error = err.Error()
		result.Allowed = false
	}

	return result
}

// CheckTaskWithSubTasks checks a task and all its subtasks
func (dam *DynamicActionMapper) CheckTaskWithSubTasks(task LLMTask) *TaskCheckResult {
	// Check main task
	result := dam.CheckTask(task)

	// Check subtasks if they exist
	if len(task.SubTasks) > 0 {
		result.SubTaskResults = make([]TaskCheckResult, len(task.SubTasks))
		allSubTasksAllowed := true

		for i, subTask := range task.SubTasks {
			subResult := dam.CheckTaskWithSubTasks(subTask) // Recursive for nested subtasks
			result.SubTaskResults[i] = *subResult

			if !subResult.Allowed {
				allSubTasksAllowed = false
				// Add subtask reasons to main task reasons
				result.Reasons = append(result.Reasons,
					fmt.Sprintf("Subtask '%s' blocked: %v", subTask.TaskName, subResult.Reasons))
			}
		}

		// If any subtask is blocked, the main task is also blocked
		if !allSubTasksAllowed {
			result.Allowed = false
		}
	}

	return result
}

// createPrinciplesRequest creates a principles API request from task and analysis
func (dam *DynamicActionMapper) createPrinciplesRequest(task LLMTask, analysis *analyzer.TaskAnalysis) map[string]interface{} {
	// Start with the analysis ethical context
	context := make(map[string]interface{})
	for k, v := range analysis.EthicalContext {
		context[k] = v
	}

	// Add original context
	for k, v := range task.Context {
		context[k] = v
	}

	// Add analysis metadata
	context["risk_level"] = analysis.RiskLevel
	context["confidence"] = analysis.Confidence
	context["generated_by"] = task.GeneratedBy

	// Create parameters
	params := make(map[string]interface{})
	params["task_name"] = task.TaskName
	params["description"] = task.Description
	params["task_type"] = task.TaskType

	// Add extracted parameters from analysis
	for k, v := range analysis.ExtractedParams {
		params[k] = v
	}

	// Add warnings to parameters
	if len(analysis.Warnings) > 0 {
		params["warnings"] = analysis.Warnings
	}

	return map[string]interface{}{
		"action":  task.TaskName,
		"params":  params,
		"context": context,
	}
}

// checkWithPrinciplesAPI sends request to principles API
func (dam *DynamicActionMapper) checkWithPrinciplesAPI(principlesReq map[string]interface{}) (bool, []string, error) {
	// Marshal request
	reqBody, err := json.Marshal(principlesReq)
	if err != nil {
		return false, nil, fmt.Errorf("failed to marshal request: %v", err)
	}

	// Send HTTP request
	resp, err := dam.httpClient.Post(
		dam.principlesAPIURL+"/action",
		"application/json",
		bytes.NewReader(reqBody),
	)
	if err != nil {
		return false, nil, fmt.Errorf("failed to send request to principles API: %v", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK {
		return false, nil, fmt.Errorf("principles API returned status %d", resp.StatusCode)
	}

	// Decode response
	var response map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return false, nil, fmt.Errorf("failed to decode response: %v", err)
	}

	// Extract reasons
	var reasons []string
	if reasonsInterface, ok := response["reasons"].([]interface{}); ok {
		for _, reason := range reasonsInterface {
			if reasonStr, ok := reason.(string); ok {
				reasons = append(reasons, reasonStr)
			}
		}
	}

	// Action is allowed if there are no reasons
	allowed := len(reasons) == 0

	return allowed, reasons, nil
}

// BatchCheckTasks checks multiple tasks in parallel
func (dam *DynamicActionMapper) BatchCheckTasks(tasks []LLMTask) []TaskCheckResult {
	results := make([]TaskCheckResult, len(tasks))

	// For now, process sequentially. Could be made parallel with goroutines
	for i, task := range tasks {
		results[i] = *dam.CheckTaskWithSubTasks(task)
	}

	return results
}

// ValidateTaskPlan validates an entire task plan before execution
func (dam *DynamicActionMapper) ValidateTaskPlan(plan []LLMTask) (bool, []string, []TaskCheckResult) {
	results := dam.BatchCheckTasks(plan)

	var blockedTasks []string
	var allAllowed = true

	for _, result := range results {
		if !result.Allowed {
			allAllowed = false
			blockedTasks = append(blockedTasks, result.TaskName)
		}
	}

	return allAllowed, blockedTasks, results
}

// GetTaskRecommendations provides recommendations for blocked tasks
func (dam *DynamicActionMapper) GetTaskRecommendations(result TaskCheckResult) []string {
	recommendations := []string{}

	if !result.Allowed && result.Analysis != nil {
		analysis := result.Analysis

		// Provide specific recommendations based on analysis
		if analysis.EthicalContext["human_harm"].(bool) {
			recommendations = append(recommendations,
				"Modify task to avoid any actions that could harm humans")
		}

		if analysis.EthicalContext["stealing"].(bool) {
			recommendations = append(recommendations,
				"Ensure proper authorization before taking any items")
		}

		if analysis.EthicalContext["unauthorized_access"].(bool) {
			recommendations = append(recommendations,
				"Obtain proper permissions before accessing restricted areas")
		}

		if analysis.RiskLevel == "high" {
			recommendations = append(recommendations,
				"Consider breaking this task into smaller, safer subtasks")
		}

		if analysis.Confidence < 0.7 {
			recommendations = append(recommendations,
				"Task description is ambiguous - provide more specific details")
		}
	}

	return recommendations
}
